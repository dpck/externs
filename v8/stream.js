/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from types-v8/stream.d.ts:
// Derived from: declare module "stream"
/**
 * @extends {events.EventEmitter}
 * @constructor
 * @struct
 */
var stream = function() {};

/**
 * @template T
 * @param {stream.T} destination
 * @param {{end: boolean}=} options
 * @return {stream.T}
 */
stream.prototype.pipe = function(destination, options) {};
/**
 * @extends {stream}
 * @constructor
 * @struct
 */
stream.Stream = function() {};
/**
 * @record
 * @struct
 */
stream.ReadableOptions = function() {};
/** @type {number} */
stream.ReadableOptions.prototype.highWaterMark;
/** @type {string} */
stream.ReadableOptions.prototype.encoding;
/** @type {boolean} */
stream.ReadableOptions.prototype.objectMode;
/** @type {function(this: (!stream.Readable), number=): ?} */
stream.ReadableOptions.prototype.read;
/** @type {function(!Error, function(!Error=): void): void} */
stream.ReadableOptions.prototype.destroy;

/**
 * @extends {stream.Stream}
 * @implements {NodeJS.ReadableStream}
 * @constructor
 * @struct
 * @param {!stream.ReadableOptions=} opts
 */
stream.Readable = function(opts) {};
/** @type {boolean} */
stream.Readable.prototype.readable;
/** @type {number} */
stream.Readable.prototype.readableHighWaterMark;

/**
 * @param {number} size
 * @return {void}
 */
stream.Readable.prototype._read = function(size) {};

/**
 * @param {number=} size
 * @return {?}
 */
stream.Readable.prototype.read = function(size) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} encoding
 * @return {THIS}
 */
stream.Readable.prototype.setEncoding = function(encoding) {};

/**
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
stream.Readable.prototype.pause = function() {};

/**
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
stream.Readable.prototype.resume = function() {};

/**
 * @return {boolean}
 */
stream.Readable.prototype.isPaused = function() {};

/**
 * @template THIS,T
 * @this {THIS}
 * @param {stream.T=} destination
 * @return {THIS}
 */
stream.Readable.prototype.unpipe = function(destination) {};

/**
 * @param {?} chunk
 * @return {void}
 */
stream.Readable.prototype.unshift = function(chunk) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {!NodeJS.ReadableStream} oldStream
 * @return {THIS}
 */
stream.Readable.prototype.wrap = function(oldStream) {};

/**
 * @param {?} chunk
 * @param {string=} encoding
 * @return {boolean}
 */
stream.Readable.prototype.push = function(chunk, encoding) {};

/**
 * @param {!Error} error
 * @param {function(!Error=): void} callback
 * @return {void}
 */
stream.Readable.prototype._destroy = function(error, callback) {};

/**
 * @param {!Error=} error
 * @return {void}
 */
stream.Readable.prototype.destroy = function(error) {};

/**
 * Event emitter
 * The defined events on documents including:
 * 1. close
 * 2. data
 * 3. end
 * 4. readable
 * 5. error
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function((string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
stream.Readable.prototype.addListener = function(event, listener) {};

/**
 * @param {(string|symbol)|string} event
 * @param {...?|(string|!Buffer)|!Error} args_or_chunk_or_err
 * @return {boolean}
 */
stream.Readable.prototype.emit = function(event, args_or_chunk_or_err) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function((string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
stream.Readable.prototype.on = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function((string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
stream.Readable.prototype.once = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function((string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
stream.Readable.prototype.prependListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function((string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
stream.Readable.prototype.prependOnceListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function((string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
stream.Readable.prototype.removeListener = function(event, listener) {};
/**
 * @record
 * @struct
 */
stream.WritableOptions = function() {};
/** @type {number} */
stream.WritableOptions.prototype.highWaterMark;
/** @type {boolean} */
stream.WritableOptions.prototype.decodeStrings;
/** @type {boolean} */
stream.WritableOptions.prototype.objectMode;
/** @type {function(?, string, !Function): ?} */
stream.WritableOptions.prototype.write;
/** @type {function(!Array<{chunk: ?, encoding: string}>, !Function): ?} */
stream.WritableOptions.prototype.writev;
/** @type {function(!Error, function(!Error=): void): void} */
stream.WritableOptions.prototype.destroy;
/** @type {function(function(!Error=): void): void} */
stream.WritableOptions.prototype.final;

/**
 * @extends {stream.Stream}
 * @implements {NodeJS.WritableStream}
 * @constructor
 * @struct
 * @param {!stream.WritableOptions=} opts
 */
stream.Writable = function(opts) {};
/** @type {boolean} */
stream.Writable.prototype.writable;
/** @type {number} */
stream.Writable.prototype.writableHighWaterMark;

/**
 * @param {?} chunk
 * @param {string} encoding
 * @param {function(!Error=): void} callback
 * @return {void}
 */
stream.Writable.prototype._write = function(chunk, encoding, callback) {};

/**
 * @param {!Array<{chunk: ?, encoding: string}>} chunks
 * @param {function(!Error=): void} callback
 * @return {void}
 */
stream.Writable.prototype._writev = function(chunks, callback) {};

/**
 * @param {!Error} error
 * @param {function(!Error=): void} callback
 * @return {void}
 */
stream.Writable.prototype._destroy = function(error, callback) {};

/**
 * @param {!Function} callback
 * @return {void}
 */
stream.Writable.prototype._final = function(callback) {};

/**
 * @param {?} chunk
 * @param {!Function|string=} cb_or_encoding
 * @param {!Function=} cb
 * @return {boolean}
 */
stream.Writable.prototype.write = function(chunk, cb_or_encoding, cb) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} encoding
 * @return {THIS}
 */
stream.Writable.prototype.setDefaultEncoding = function(encoding) {};

/**
 * @param {!Function|?=} cb_or_chunk
 * @param {!Function|string=} cb_or_encoding
 * @param {!Function=} cb
 * @return {void}
 */
stream.Writable.prototype.end = function(cb_or_chunk, cb_or_encoding, cb) {};

/**
 * @return {void}
 */
stream.Writable.prototype.cork = function() {};

/**
 * @return {void}
 */
stream.Writable.prototype.uncork = function() {};

/**
 * @param {!Error=} error
 * @return {void}
 */
stream.Writable.prototype.destroy = function(error) {};

/**
 * Event emitter
 * The defined events on documents including:
 * 1. close
 * 2. drain
 * 3. error
 * 4. finish
 * 5. pipe
 * 6. unpipe
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(!Error): void|function(!stream.Readable): void} listener
 * @return {THIS}
 */
stream.Writable.prototype.addListener = function(event, listener) {};

/**
 * @param {(string|symbol)|string} event
 * @param {...?|(string|!Buffer)|!Error|!stream.Readable} args_or_chunk_or_err_or_src
 * @return {boolean}
 */
stream.Writable.prototype.emit = function(event, args_or_chunk_or_err_or_src) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(!Error): void|function(!stream.Readable): void} listener
 * @return {THIS}
 */
stream.Writable.prototype.on = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(!Error): void|function(!stream.Readable): void} listener
 * @return {THIS}
 */
stream.Writable.prototype.once = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(!Error): void|function(!stream.Readable): void} listener
 * @return {THIS}
 */
stream.Writable.prototype.prependListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(!Error): void|function(!stream.Readable): void} listener
 * @return {THIS}
 */
stream.Writable.prototype.prependOnceListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(!Error): void|function(!stream.Readable): void} listener
 * @return {THIS}
 */
stream.Writable.prototype.removeListener = function(event, listener) {};
/**
 * @extends {stream.ReadableOptions}
 * @extends {stream.WritableOptions}
 * @record
 * @struct
 */
stream.DuplexOptions = function() {};
/** @type {boolean} */
stream.DuplexOptions.prototype.allowHalfOpen;
/** @type {boolean} */
stream.DuplexOptions.prototype.readableObjectMode;
/** @type {boolean} */
stream.DuplexOptions.prototype.writableObjectMode;

/**
 * @extends {stream.Readable}
 * @constructor
 * @struct
 * @param {!stream.DuplexOptions=} opts
 */
stream.Duplex = function(opts) {};
/** @type {boolean} */
stream.Duplex.prototype.writable;
/** @type {number} */
stream.Duplex.prototype.writableHighWaterMark;

/**
 * @param {?} chunk
 * @param {string} encoding
 * @param {function(!Error=): void} callback
 * @return {void}
 */
stream.Duplex.prototype._write = function(chunk, encoding, callback) {};

/**
 * @param {!Array<{chunk: ?, encoding: string}>} chunks
 * @param {function(!Error=): void} callback
 * @return {void}
 */
stream.Duplex.prototype._writev = function(chunks, callback) {};

/**
 * @param {!Error} error
 * @param {function(!Error=): void} callback
 * @return {void}
 */
stream.Duplex.prototype._destroy = function(error, callback) {};

/**
 * @param {!Function} callback
 * @return {void}
 */
stream.Duplex.prototype._final = function(callback) {};

/**
 * @param {?} chunk
 * @param {!Function|string=} cb_or_encoding
 * @param {!Function=} cb
 * @return {boolean}
 */
stream.Duplex.prototype.write = function(chunk, cb_or_encoding, cb) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} encoding
 * @return {THIS}
 */
stream.Duplex.prototype.setDefaultEncoding = function(encoding) {};

/**
 * @param {!Function|?=} cb_or_chunk
 * @param {!Function|string=} cb_or_encoding
 * @param {!Function=} cb
 * @return {void}
 */
stream.Duplex.prototype.end = function(cb_or_chunk, cb_or_encoding, cb) {};

/**
 * @return {void}
 */
stream.Duplex.prototype.cork = function() {};

/**
 * @return {void}
 */
stream.Duplex.prototype.uncork = function() {};
/**
 * @extends {stream.DuplexOptions}
 * @record
 * @struct
 */
stream.TransformOptions = function() {};
/** @type {function((string|!Buffer), string, !Function): ?} */
stream.TransformOptions.prototype.transform;
/** @type {function(!Function): ?} */
stream.TransformOptions.prototype.flush;

/**
 * @extends {stream.Duplex}
 * @constructor
 * @struct
 * @param {!stream.TransformOptions=} opts
 */
stream.Transform = function(opts) {};

/**
 * @param {?} chunk
 * @param {string} encoding
 * @param {!Function} callback
 * @return {void}
 */
stream.Transform.prototype._transform = function(chunk, encoding, callback) {};

/**
 * @param {!Error=} error
 * @return {void}
 */
stream.Transform.prototype.destroy = function(error) {};
/**
 * @extends {stream.Transform}
 * @constructor
 * @struct
 */
stream.PassThrough = function() {};
