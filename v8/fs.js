/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from types-v8/fs.d.ts:
// Derived from: declare module "fs"
/** @const */
var fs = {};

/** @typedef {(string|!Buffer|!url.URL)} */
fs.PathLike;
/**
 * @constructor
 * @struct
 */
fs.Stats = function() {};
/** @type {number} */
fs.Stats.prototype.dev;
/** @type {number} */
fs.Stats.prototype.ino;
/** @type {number} */
fs.Stats.prototype.mode;
/** @type {number} */
fs.Stats.prototype.nlink;
/** @type {number} */
fs.Stats.prototype.uid;
/** @type {number} */
fs.Stats.prototype.gid;
/** @type {number} */
fs.Stats.prototype.rdev;
/** @type {number} */
fs.Stats.prototype.size;
/** @type {number} */
fs.Stats.prototype.blksize;
/** @type {number} */
fs.Stats.prototype.blocks;
/** @type {number} */
fs.Stats.prototype.atimeMs;
/** @type {number} */
fs.Stats.prototype.mtimeMs;
/** @type {number} */
fs.Stats.prototype.ctimeMs;
/** @type {number} */
fs.Stats.prototype.birthtimeMs;
/** @type {!Date} */
fs.Stats.prototype.atime;
/** @type {!Date} */
fs.Stats.prototype.mtime;
/** @type {!Date} */
fs.Stats.prototype.ctime;
/** @type {!Date} */
fs.Stats.prototype.birthtime;

/**
 * @return {boolean}
 */
fs.Stats.prototype.isFile = function() {};

/**
 * @return {boolean}
 */
fs.Stats.prototype.isDirectory = function() {};

/**
 * @return {boolean}
 */
fs.Stats.prototype.isBlockDevice = function() {};

/**
 * @return {boolean}
 */
fs.Stats.prototype.isCharacterDevice = function() {};

/**
 * @return {boolean}
 */
fs.Stats.prototype.isSymbolicLink = function() {};

/**
 * @return {boolean}
 */
fs.Stats.prototype.isFIFO = function() {};

/**
 * @return {boolean}
 */
fs.Stats.prototype.isSocket = function() {};
/**
 * @extends {events.EventEmitter}
 * @record
 * @struct
 */
fs.FSWatcher = function() {};

/**
 * @return {void}
 */
fs.FSWatcher.prototype.close = function() {};

/**
 * events.EventEmitter
 *   1. change
 *   2. error
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(string, (string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
fs.FSWatcher.prototype.addListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(string, (string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
fs.FSWatcher.prototype.on = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(string, (string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
fs.FSWatcher.prototype.once = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(string, (string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
fs.FSWatcher.prototype.prependListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(string, (string|!Buffer)): void|function(!Error): void} listener
 * @return {THIS}
 */
fs.FSWatcher.prototype.prependOnceListener = function(event, listener) {};
/**
 * @extends {stream.Readable}
 * @constructor
 * @struct
 */
fs.ReadStream = function() {};
/** @type {number} */
fs.ReadStream.prototype.bytesRead;
/** @type {(string|!Buffer)} */
fs.ReadStream.prototype.path;

/**
 * @return {void}
 */
fs.ReadStream.prototype.close = function() {};

/**
 * @return {void}
 */
fs.ReadStream.prototype.destroy = function() {};

/**
 * events.EventEmitter
 *   1. open
 *   2. close
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(number): void|function(): void} listener
 * @return {THIS}
 */
fs.ReadStream.prototype.addListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(number): void|function(): void} listener
 * @return {THIS}
 */
fs.ReadStream.prototype.on = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(number): void|function(): void} listener
 * @return {THIS}
 */
fs.ReadStream.prototype.once = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(number): void|function(): void} listener
 * @return {THIS}
 */
fs.ReadStream.prototype.prependListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(number): void|function(): void} listener
 * @return {THIS}
 */
fs.ReadStream.prototype.prependOnceListener = function(event, listener) {};
/**
 * @extends {stream.Writable}
 * @constructor
 * @struct
 */
fs.WriteStream = function() {};
/** @type {number} */
fs.WriteStream.prototype.bytesWritten;
/** @type {(string|!Buffer)} */
fs.WriteStream.prototype.path;

/**
 * @return {void}
 */
fs.WriteStream.prototype.close = function() {};

/**
 * events.EventEmitter
 *   1. open
 *   2. close
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(number): void|function(): void} listener
 * @return {THIS}
 */
fs.WriteStream.prototype.addListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(number): void|function(): void} listener
 * @return {THIS}
 */
fs.WriteStream.prototype.on = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(number): void|function(): void} listener
 * @return {THIS}
 */
fs.WriteStream.prototype.once = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(number): void|function(): void} listener
 * @return {THIS}
 */
fs.WriteStream.prototype.prependListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(number): void|function(): void} listener
 * @return {THIS}
 */
fs.WriteStream.prototype.prependOnceListener = function(event, listener) {};

/**
 * Asynchronous rename(2) - Change the name or location of a file or directory.
 * @param {(string|!Buffer|!url.URL)} oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {(string|!Buffer|!url.URL)} newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.rename = function(oldPath, newPath, callback) {};

/**
 * Asynchronous rename(2) - Change the name or location of a file or directory.
 * @param {(string|!Buffer|!url.URL)} oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {(string|!Buffer|!url.URL)} newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @return {!Promise<void>}
 */
fs.rename.__promisify__ = function(oldPath, newPath) {};

/**
 * Synchronous rename(2) - Change the name or location of a file or directory.
 * @param {(string|!Buffer|!url.URL)} oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {(string|!Buffer|!url.URL)} newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @return {void}
 */
fs.renameSync = function(oldPath, newPath) {};

/**
 * Asynchronous truncate(2) - Truncate a file to a specified length.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol. / A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {number|function(!NodeJS.ErrnoException): void} len_or_callback If not specified, defaults to `0`.
 * @param {function(!NodeJS.ErrnoException): void=} callback
 * @return {void}
 */
fs.truncate = function(path, len_or_callback, callback) {};

/**
 * Asynchronous truncate(2) - Truncate a file to a specified length.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {number=} len If not specified, defaults to `0`.
 * @return {!Promise<void>}
 */
fs.truncate.__promisify__ = function(path, len) {};

/**
 * Synchronous truncate(2) - Truncate a file to a specified length.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {number=} len If not specified, defaults to `0`.
 * @return {void}
 */
fs.truncateSync = function(path, len) {};

/**
 * Asynchronous ftruncate(2) - Truncate a file to a specified length.
 * @param {number} fd A file descriptor.
 * @param {number|function(!NodeJS.ErrnoException): void} len_or_callback If not specified, defaults to `0`.
 * @param {function(!NodeJS.ErrnoException): void=} callback
 * @return {void}
 */
fs.ftruncate = function(fd, len_or_callback, callback) {};

/**
 * Asynchronous ftruncate(2) - Truncate a file to a specified length.
 * @param {number} fd A file descriptor.
 * @param {number=} len If not specified, defaults to `0`.
 * @return {!Promise<void>}
 */
fs.ftruncate.__promisify__ = function(fd, len) {};

/**
 * Synchronous ftruncate(2) - Truncate a file to a specified length.
 * @param {number} fd A file descriptor.
 * @param {number=} len If not specified, defaults to `0`.
 * @return {void}
 */
fs.ftruncateSync = function(fd, len) {};

/**
 * Asynchronous chown(2) - Change ownership of a file.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {number} uid
 * @param {number} gid
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.chown = function(path, uid, gid, callback) {};

/**
 * Asynchronous chown(2) - Change ownership of a file.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {number} uid
 * @param {number} gid
 * @return {!Promise<void>}
 */
fs.chown.__promisify__ = function(path, uid, gid) {};

/**
 * Synchronous chown(2) - Change ownership of a file.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {number} uid
 * @param {number} gid
 * @return {void}
 */
fs.chownSync = function(path, uid, gid) {};

/**
 * Asynchronous fchown(2) - Change ownership of a file.
 * @param {number} fd A file descriptor.
 * @param {number} uid
 * @param {number} gid
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.fchown = function(fd, uid, gid, callback) {};

/**
 * Asynchronous fchown(2) - Change ownership of a file.
 * @param {number} fd A file descriptor.
 * @param {number} uid
 * @param {number} gid
 * @return {!Promise<void>}
 */
fs.fchown.__promisify__ = function(fd, uid, gid) {};

/**
 * Synchronous fchown(2) - Change ownership of a file.
 * @param {number} fd A file descriptor.
 * @param {number} uid
 * @param {number} gid
 * @return {void}
 */
fs.fchownSync = function(fd, uid, gid) {};

/**
 * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {number} uid
 * @param {number} gid
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.lchown = function(path, uid, gid, callback) {};

/**
 * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {number} uid
 * @param {number} gid
 * @return {!Promise<void>}
 */
fs.lchown.__promisify__ = function(path, uid, gid) {};

/**
 * Synchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {number} uid
 * @param {number} gid
 * @return {void}
 */
fs.lchownSync = function(path, uid, gid) {};

/**
 * Asynchronous chmod(2) - Change permissions of a file.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)} mode A file mode. If a string is passed, it is parsed as an octal integer.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.chmod = function(path, mode, callback) {};

/**
 * Asynchronous chmod(2) - Change permissions of a file.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)} mode A file mode. If a string is passed, it is parsed as an octal integer.
 * @return {!Promise<void>}
 */
fs.chmod.__promisify__ = function(path, mode) {};

/**
 * Synchronous chmod(2) - Change permissions of a file.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)} mode A file mode. If a string is passed, it is parsed as an octal integer.
 * @return {void}
 */
fs.chmodSync = function(path, mode) {};

/**
 * Asynchronous fchmod(2) - Change permissions of a file.
 * @param {number} fd A file descriptor.
 * @param {(string|number)} mode A file mode. If a string is passed, it is parsed as an octal integer.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.fchmod = function(fd, mode, callback) {};

/**
 * Asynchronous fchmod(2) - Change permissions of a file.
 * @param {number} fd A file descriptor.
 * @param {(string|number)} mode A file mode. If a string is passed, it is parsed as an octal integer.
 * @return {!Promise<void>}
 */
fs.fchmod.__promisify__ = function(fd, mode) {};

/**
 * Synchronous fchmod(2) - Change permissions of a file.
 * @param {number} fd A file descriptor.
 * @param {(string|number)} mode A file mode. If a string is passed, it is parsed as an octal integer.
 * @return {void}
 */
fs.fchmodSync = function(fd, mode) {};

/**
 * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)} mode A file mode. If a string is passed, it is parsed as an octal integer.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.lchmod = function(path, mode, callback) {};

/**
 * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)} mode A file mode. If a string is passed, it is parsed as an octal integer.
 * @return {!Promise<void>}
 */
fs.lchmod.__promisify__ = function(path, mode) {};

/**
 * Synchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)} mode A file mode. If a string is passed, it is parsed as an octal integer.
 * @return {void}
 */
fs.lchmodSync = function(path, mode) {};

/**
 * Asynchronous stat(2) - Get file status.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {function(!NodeJS.ErrnoException, !fs.Stats): void} callback
 * @return {void}
 */
fs.stat = function(path, callback) {};

/**
 * Asynchronous stat(2) - Get file status.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @return {!Promise<!fs.Stats>}
 */
fs.stat.__promisify__ = function(path) {};

/**
 * Synchronous stat(2) - Get file status.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @return {!fs.Stats}
 */
fs.statSync = function(path) {};

/**
 * Asynchronous fstat(2) - Get file status.
 * @param {number} fd A file descriptor.
 * @param {function(!NodeJS.ErrnoException, !fs.Stats): void} callback
 * @return {void}
 */
fs.fstat = function(fd, callback) {};

/**
 * Asynchronous fstat(2) - Get file status.
 * @param {number} fd A file descriptor.
 * @return {!Promise<!fs.Stats>}
 */
fs.fstat.__promisify__ = function(fd) {};

/**
 * Synchronous fstat(2) - Get file status.
 * @param {number} fd A file descriptor.
 * @return {!fs.Stats}
 */
fs.fstatSync = function(fd) {};

/**
 * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {function(!NodeJS.ErrnoException, !fs.Stats): void} callback
 * @return {void}
 */
fs.lstat = function(path, callback) {};

/**
 * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @return {!Promise<!fs.Stats>}
 */
fs.lstat.__promisify__ = function(path) {};

/**
 * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @return {!fs.Stats}
 */
fs.lstatSync = function(path) {};

/**
 * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
 * @param {(string|!Buffer|!url.URL)} existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|!Buffer|!url.URL)} newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.link = function(existingPath, newPath, callback) {};

/**
 * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
 * @param {(string|!Buffer|!url.URL)} existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|!Buffer|!url.URL)} newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @return {!Promise<void>}
 */
fs.link.link = function(existingPath, newPath) {};

/**
 * Synchronous link(2) - Create a new link (also known as a hard link) to an existing file.
 * @param {(string|!Buffer|!url.URL)} existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|!Buffer|!url.URL)} newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @return {void}
 */
fs.linkSync = function(existingPath, newPath) {};

/**
 * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
 * @param {(string|!Buffer|!url.URL)} target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|!Buffer|!url.URL)} path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
 * @param {string|function(!NodeJS.ErrnoException): void} type_or_callback May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
 * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
 * @param {function(!NodeJS.ErrnoException): void=} callback
 * @return {void}
 */
fs.symlink = function(target, path, type_or_callback, callback) {};

/**
 * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
 * @param {(string|!Buffer|!url.URL)} target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|!Buffer|!url.URL)} path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
 * @param {string=} type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
 * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
 * @return {!Promise<void>}
 */
fs.symlink.__promisify__ = function(target, path, type) {};

/** @typedef {string} */
fs.symlink.Type;

/**
 * Synchronous symlink(2) - Create a new symbolic link to an existing file.
 * @param {(string|!Buffer|!url.URL)} target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|!Buffer|!url.URL)} path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
 * @param {string=} type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
 * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
 * @return {void}
 */
fs.symlinkSync = function(target, path, type) {};

/**
 * Asynchronous readlink(2) - read value of a symbolic link.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {({encoding: string}|string)|(string|{encoding: string})|function(!NodeJS.ErrnoException, string): void} options_or_callback The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @param {function(!NodeJS.ErrnoException, string): void|function(!NodeJS.ErrnoException, !Buffer): void|function(!NodeJS.ErrnoException, (string|!Buffer)): void=} callback
 * @return {void}
 */
fs.readlink = function(path, options_or_callback, callback) {};

/**
 * Asynchronous readlink(2) - read value of a symbolic link.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|{encoding: string})=} options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @return {!Promise<string>|!Promise<!Buffer>|!Promise<(string|!Buffer)>}
 */
fs.readlink.__promisify__ = function(path, options) {};

/**
 * Synchronous readlink(2) - read value of a symbolic link.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|{encoding: string})=} options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @return {string|!Buffer|(string|!Buffer)}
 */
fs.readlinkSync = function(path, options) {};

/**
 * Asynchronous realpath(3) - return the canonicalized absolute pathname.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|{encoding: string})|function(!NodeJS.ErrnoException, string): void} options_or_callback The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @param {function(!NodeJS.ErrnoException, string): void|function(!NodeJS.ErrnoException, !Buffer): void|function(!NodeJS.ErrnoException, (string|!Buffer)): void=} callback
 * @return {void}
 */
fs.realpath = function(path, options_or_callback, callback) {};

/**
 * Asynchronous realpath(3) - return the canonicalized absolute pathname.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|{encoding: string})=} options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @return {!Promise<string>|!Promise<!Buffer>|!Promise<(string|!Buffer)>}
 */
fs.realpath.__promisify__ = function(path, options) {};

/**
 * Synchronous realpath(3) - return the canonicalized absolute pathname.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|{encoding: string})=} options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @return {string|!Buffer|(string|!Buffer)}
 */
fs.realpathSync = function(path, options) {};

/**
 * Asynchronous unlink(2) - delete a name and possibly the file it refers to.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.unlink = function(path, callback) {};

/**
 * Asynchronous unlink(2) - delete a name and possibly the file it refers to.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @return {!Promise<void>}
 */
fs.unlink.__promisify__ = function(path) {};

/**
 * Synchronous unlink(2) - delete a name and possibly the file it refers to.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @return {void}
 */
fs.unlinkSync = function(path) {};

/**
 * Asynchronous rmdir(2) - delete a directory.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.rmdir = function(path, callback) {};

/**
 * Asynchronous rmdir(2) - delete a directory.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @return {!Promise<void>}
 */
fs.rmdir.__promisify__ = function(path) {};

/**
 * Synchronous rmdir(2) - delete a directory.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @return {void}
 */
fs.rmdirSync = function(path) {};

/**
 * Asynchronous mkdir(2) - create a directory. / Asynchronous mkdir(2) - create a directory with a mode of `0o777`.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)|function(!NodeJS.ErrnoException): void} mode_or_callback A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
 * @param {function(!NodeJS.ErrnoException): void=} callback
 * @return {void}
 */
fs.mkdir = function(path, mode_or_callback, callback) {};

/**
 * Asynchronous mkdir(2) - create a directory.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)=} mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
 * @return {!Promise<void>}
 */
fs.mkdir.__promisify__ = function(path, mode) {};

/**
 * Synchronous mkdir(2) - create a directory.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)=} mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
 * @return {void}
 */
fs.mkdirSync = function(path, mode) {};

/**
 * Asynchronously creates a unique temporary directory.
 * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
 * @param {string} prefix
 * @param {(string|{encoding: string})|function(!NodeJS.ErrnoException, string): void} options_or_callback The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @param {function(!NodeJS.ErrnoException, string): void|function(!NodeJS.ErrnoException, !Buffer): void|function(!NodeJS.ErrnoException, (string|!Buffer)): void=} callback
 * @return {void}
 */
fs.mkdtemp = function(prefix, options_or_callback, callback) {};

/**
 * Asynchronously creates a unique temporary directory.
 * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
 * @param {string} prefix
 * @param {(string|{encoding: string})=} options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @return {!Promise<string>|!Promise<!Buffer>|!Promise<(string|!Buffer)>}
 */
fs.mkdtemp.__promisify__ = function(prefix, options) {};

/**
 * Synchronously creates a unique temporary directory.
 * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
 * @param {string} prefix
 * @param {(string|{encoding: string})=} options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @return {string|!Buffer|(string|!Buffer)}
 */
fs.mkdtempSync = function(prefix, options) {};

/**
 * Asynchronous readdir(3) - read a directory.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|{encoding: string})|function(!NodeJS.ErrnoException, !Array<string>): void} options_or_callback The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @param {function(!NodeJS.ErrnoException, !Array<string>): void|function(!NodeJS.ErrnoException, !Array<!Buffer>): void|function(!NodeJS.ErrnoException, (!Array<string>|!Array<!Buffer>)): void=} callback
 * @return {void}
 */
fs.readdir = function(path, options_or_callback, callback) {};

/**
 * Asynchronous readdir(3) - read a directory.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|{encoding: string})=} options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @return {!Promise<!Array<string>>|!Promise<!Array<!Buffer>>|!Promise<(!Array<string>|!Array<!Buffer>)>}
 */
fs.readdir.__promisify__ = function(path, options) {};

/**
 * Synchronous readdir(3) - read a directory.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|{encoding: string})=} options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 * @return {!Array<string>|!Array<!Buffer>|(!Array<string>|!Array<!Buffer>)}
 */
fs.readdirSync = function(path, options) {};

/**
 * Asynchronous close(2) - close a file descriptor.
 * @param {number} fd A file descriptor.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.close = function(fd, callback) {};

/**
 * Asynchronous close(2) - close a file descriptor.
 * @param {number} fd A file descriptor.
 * @return {!Promise<void>}
 */
fs.close.__promisify__ = function(fd) {};

/**
 * Synchronous close(2) - close a file descriptor.
 * @param {number} fd A file descriptor.
 * @return {void}
 */
fs.closeSync = function(fd) {};

/**
 * Asynchronous open(2) - open and possibly create a file. / Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)} flags
 * @param {(string|number)|function(!NodeJS.ErrnoException, number): void} mode_or_callback A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
 * @param {function(!NodeJS.ErrnoException, number): void=} callback
 * @return {void}
 */
fs.open = function(path, flags, mode_or_callback, callback) {};

/**
 * Asynchronous open(2) - open and possibly create a file.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)} flags
 * @param {(string|number)=} mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
 * @return {!Promise<number>}
 */
fs.open.__promisify__ = function(path, flags, mode) {};

/**
 * Synchronous open(2) - open and possibly create a file, returning a file descriptor..
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number)} flags
 * @param {(string|number)=} mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
 * @return {number}
 */
fs.openSync = function(path, flags, mode) {};

/**
 * Asynchronously change file timestamps of the file referenced by the supplied path.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number|!Date)} atime The last access time. If a string is provided, it will be coerced to number.
 * @param {(string|number|!Date)} mtime The last modified time. If a string is provided, it will be coerced to number.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.utimes = function(path, atime, mtime, callback) {};

/**
 * Asynchronously change file timestamps of the file referenced by the supplied path.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number|!Date)} atime The last access time. If a string is provided, it will be coerced to number.
 * @param {(string|number|!Date)} mtime The last modified time. If a string is provided, it will be coerced to number.
 * @return {!Promise<void>}
 */
fs.utimes.__promisify__ = function(path, atime, mtime) {};

/**
 * Synchronously change file timestamps of the file referenced by the supplied path.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param {(string|number|!Date)} atime The last access time. If a string is provided, it will be coerced to number.
 * @param {(string|number|!Date)} mtime The last modified time. If a string is provided, it will be coerced to number.
 * @return {void}
 */
fs.utimesSync = function(path, atime, mtime) {};

/**
 * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
 * @param {number} fd A file descriptor.
 * @param {(string|number|!Date)} atime The last access time. If a string is provided, it will be coerced to number.
 * @param {(string|number|!Date)} mtime The last modified time. If a string is provided, it will be coerced to number.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.futimes = function(fd, atime, mtime, callback) {};

/**
 * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
 * @param {number} fd A file descriptor.
 * @param {(string|number|!Date)} atime The last access time. If a string is provided, it will be coerced to number.
 * @param {(string|number|!Date)} mtime The last modified time. If a string is provided, it will be coerced to number.
 * @return {!Promise<void>}
 */
fs.futimes.__promisify__ = function(fd, atime, mtime) {};

/**
 * Synchronously change file timestamps of the file referenced by the supplied file descriptor.
 * @param {number} fd A file descriptor.
 * @param {(string|number|!Date)} atime The last access time. If a string is provided, it will be coerced to number.
 * @param {(string|number|!Date)} mtime The last modified time. If a string is provided, it will be coerced to number.
 * @return {void}
 */
fs.futimesSync = function(fd, atime, mtime) {};

/**
 * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
 * @param {number} fd A file descriptor.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.fsync = function(fd, callback) {};

/**
 * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
 * @param {number} fd A file descriptor.
 * @return {!Promise<void>}
 */
fs.fsync.__promisify__ = function(fd) {};

/**
 * Synchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
 * @param {number} fd A file descriptor.
 * @return {void}
 */
fs.fsyncSync = function(fd) {};

/**
 * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor. / Asynchronously writes `string` to the file referenced by the supplied file descriptor. / Asynchronously writes `string` to the file referenced by the supplied file descriptor. / Asynchronously writes `string` to the file referenced by the supplied file descriptor.
 * @template TBuffer
 * @param {number} fd A file descriptor.
 * @param {fs.TBuffer|?} buffer_or_string A string to write. If something other than a string is supplied it will be coerced to a string.
 * @param {number|function(!NodeJS.ErrnoException, number, fs.TBuffer): void|function(!NodeJS.ErrnoException, number, string): void} offset_or_callback_or_position The part of the buffer to be written. If not supplied, defaults to `0`. / The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
 * @param {number|function(!NodeJS.ErrnoException, number, fs.TBuffer): void|string|function(!NodeJS.ErrnoException, number, string): void=} length_or_callback_or_encoding The number of bytes to write. If not supplied, defaults to `buffer.length - offset`. / The expected string encoding.
 * @param {number|function(!NodeJS.ErrnoException, number, fs.TBuffer): void|function(!NodeJS.ErrnoException, number, string): void=} position_or_callback The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
 * @param {function(!NodeJS.ErrnoException, number, fs.TBuffer): void=} callback
 * @return {void}
 */
fs.write = function(fd, buffer_or_string, offset_or_callback_or_position, length_or_callback_or_encoding, position_or_callback, callback) {};

/**
 * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor. / Asynchronously writes `string` to the file referenced by the supplied file descriptor.
 * @template TBuffer
 * @param {number} fd A file descriptor.
 * @param {fs.TBuffer|?=} buffer_or_string A string to write. If something other than a string is supplied it will be coerced to a string.
 * @param {number=} offset_or_position The part of the buffer to be written. If not supplied, defaults to `0`. / The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
 * @param {number|string=} length_or_encoding The number of bytes to write. If not supplied, defaults to `buffer.length - offset`. / The expected string encoding.
 * @param {number=} position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
 * @return {!Promise<{bytesWritten: number, buffer: fs.TBuffer}>|!Promise<{bytesWritten: number, buffer: string}>}
 */
fs.write.__promisify__ = function(fd, buffer_or_string, offset_or_position, length_or_encoding, position) {};

/**
 * Synchronously writes `buffer` to the file referenced by the supplied file descriptor, returning the number of bytes written. / Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.
 * @param {number} fd A file descriptor.
 * @param {(!Buffer|!Uint8Array)|?} buffer_or_string A string to write. If something other than a string is supplied it will be coerced to a string.
 * @param {number=} offset_or_position The part of the buffer to be written. If not supplied, defaults to `0`. / The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
 * @param {number|string=} length_or_encoding The number of bytes to write. If not supplied, defaults to `buffer.length - offset`. / The expected string encoding.
 * @param {number=} position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
 * @return {number}
 */
fs.writeSync = function(fd, buffer_or_string, offset_or_position, length_or_encoding, position) {};

/**
 * Asynchronously reads data from the file referenced by the supplied file descriptor.
 * @template TBuffer
 * @param {number} fd A file descriptor.
 * @param {fs.TBuffer} buffer The buffer that the data will be written to.
 * @param {number} offset The offset in the buffer at which to start writing.
 * @param {number} length The number of bytes to read.
 * @param {number} position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
 * @param {function(!NodeJS.ErrnoException, number, fs.TBuffer): void=} callback
 * @return {void}
 */
fs.read = function(fd, buffer, offset, length, position, callback) {};

/**
 * @template TBuffer
 * @param {number} fd A file descriptor.
 * @param {fs.TBuffer} buffer The buffer that the data will be written to.
 * @param {number} offset The offset in the buffer at which to start writing.
 * @param {number} length The number of bytes to read.
 * @param {number} position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
 * @return {!Promise<{bytesRead: number, buffer: fs.TBuffer}>}
 */
fs.read.__promisify__ = function(fd, buffer, offset, length, position) {};

/**
 * Synchronously reads data from the file referenced by the supplied file descriptor, returning the number of bytes read.
 * @param {number} fd A file descriptor.
 * @param {(!Buffer|!Uint8Array)} buffer The buffer that the data will be written to.
 * @param {number} offset The offset in the buffer at which to start writing.
 * @param {number} length The number of bytes to read.
 * @param {number} position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
 * @return {number}
 */
fs.readSync = function(fd, buffer, offset, length, position) {};

/**
 * Asynchronously reads the entire contents of a file.
 * @param {(string|number|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically. / A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
 * @param {{encoding: null, flag: string}|(string|{encoding: string, flag: string})|function(!NodeJS.ErrnoException, !Buffer): void} options_or_callback An object that may contain an optional flag.
 * If a flag is not provided, it defaults to `'r'`. / Either the encoding for the result, or an object that contains the encoding and an optional flag.
 * If a flag is not provided, it defaults to `'r'`.
 * @param {function(!NodeJS.ErrnoException, !Buffer): void|function(!NodeJS.ErrnoException, string): void|function(!NodeJS.ErrnoException, (string|!Buffer)): void=} callback
 * @return {void}
 */
fs.readFile = function(path, options_or_callback, callback) {};

/**
 * Asynchronously reads the entire contents of a file.
 * @param {(string|number|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically. / A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
 * @param {{encoding: null, flag: string}|(string|{encoding: string, flag: string})=} options An object that may contain an optional flag.
 * If a flag is not provided, it defaults to `'r'`. / Either the encoding for the result, or an object that contains the encoding and an optional flag.
 * If a flag is not provided, it defaults to `'r'`.
 * @return {!Promise<!Buffer>|!Promise<string>|!Promise<(string|!Buffer)>}
 */
fs.readFile.__promisify__ = function(path, options) {};

/**
 * Synchronously reads the entire contents of a file.
 * @param {(string|number|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
 * @param {{encoding: null, flag: string}|(string|{encoding: string, flag: string})=} options An object that may contain an optional flag. If a flag is not provided, it defaults to `'r'`. / Either the encoding for the result, or an object that contains the encoding and an optional flag.
 * If a flag is not provided, it defaults to `'r'`.
 * @return {!Buffer|string|(string|!Buffer)}
 */
fs.readFileSync = function(path, options) {};

/**
 * Asynchronously writes data to a file, replacing the file if it already exists.
 * @param {(string|number|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
 * @param {?} data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
 * @param {(string|{encoding: string, mode: (string|number), flag: string})|function(!NodeJS.ErrnoException): void} options_or_callback Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
 * If `encoding` is not supplied, the default of `'utf8'` is used.
 * If `mode` is not supplied, the default of `0o666` is used.
 * If `mode` is a string, it is parsed as an octal integer.
 * If `flag` is not supplied, the default of `'w'` is used.
 * @param {function(!NodeJS.ErrnoException): void=} callback
 * @return {void}
 */
fs.writeFile = function(path, data, options_or_callback, callback) {};

/**
 * Asynchronously writes data to a file, replacing the file if it already exists.
 * @param {(string|number|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
 * @param {?} data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
 * @param {(string|{encoding: string, mode: (string|number), flag: string})=} options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
 * If `encoding` is not supplied, the default of `'utf8'` is used.
 * If `mode` is not supplied, the default of `0o666` is used.
 * If `mode` is a string, it is parsed as an octal integer.
 * If `flag` is not supplied, the default of `'w'` is used.
 * @return {!Promise<void>}
 */
fs.writeFile.__promisify__ = function(path, data, options) {};

/**
 * Synchronously writes data to a file, replacing the file if it already exists.
 * @param {(string|number|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
 * @param {?} data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
 * @param {(string|{encoding: string, mode: (string|number), flag: string})=} options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
 * If `encoding` is not supplied, the default of `'utf8'` is used.
 * If `mode` is not supplied, the default of `0o666` is used.
 * If `mode` is a string, it is parsed as an octal integer.
 * If `flag` is not supplied, the default of `'w'` is used.
 * @return {void}
 */
fs.writeFileSync = function(path, data, options) {};

/**
 * Asynchronously append data to a file, creating the file if it does not exist.
 * @param {(string|number|!Buffer|!url.URL)} file A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
 * @param {?} data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
 * @param {(string|{encoding: string, mode: (string|number), flag: string})|function(!NodeJS.ErrnoException): void} options_or_callback Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
 * If `encoding` is not supplied, the default of `'utf8'` is used.
 * If `mode` is not supplied, the default of `0o666` is used.
 * If `mode` is a string, it is parsed as an octal integer.
 * If `flag` is not supplied, the default of `'a'` is used.
 * @param {function(!NodeJS.ErrnoException): void=} callback
 * @return {void}
 */
fs.appendFile = function(file, data, options_or_callback, callback) {};

/**
 * Asynchronously append data to a file, creating the file if it does not exist.
 * @param {(string|number|!Buffer|!url.URL)} file A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
 * @param {?} data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
 * @param {(string|{encoding: string, mode: (string|number), flag: string})=} options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
 * If `encoding` is not supplied, the default of `'utf8'` is used.
 * If `mode` is not supplied, the default of `0o666` is used.
 * If `mode` is a string, it is parsed as an octal integer.
 * If `flag` is not supplied, the default of `'a'` is used.
 * @return {!Promise<void>}
 */
fs.appendFile.__promisify__ = function(file, data, options) {};

/**
 * Synchronously append data to a file, creating the file if it does not exist.
 * @param {(string|number|!Buffer|!url.URL)} file A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
 * @param {?} data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
 * @param {(string|{encoding: string, mode: (string|number), flag: string})=} options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
 * If `encoding` is not supplied, the default of `'utf8'` is used.
 * If `mode` is not supplied, the default of `0o666` is used.
 * If `mode` is a string, it is parsed as an octal integer.
 * If `flag` is not supplied, the default of `'a'` is used.
 * @return {void}
 */
fs.appendFileSync = function(file, data, options) {};

/**
 * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.
 * @param {(string|!Buffer|!url.URL)} filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {{persistent: boolean, interval: number}|function(!fs.Stats, !fs.Stats): void} options_or_listener
 * @param {function(!fs.Stats, !fs.Stats): void=} listener
 * @return {void}
 */
fs.watchFile = function(filename, options_or_listener, listener) {};

/**
 * Stop watching for changes on `filename`.
 * @param {(string|!Buffer|!url.URL)} filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {function(!fs.Stats, !fs.Stats): void=} listener
 * @return {void}
 */
fs.unwatchFile = function(filename, listener) {};

/**
 * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
 * @param {(string|!Buffer|!url.URL)} filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {(string|{encoding: string, persistent: boolean, recursive: boolean})|function(string, string): ?=} options_or_listener Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
 * If `encoding` is not supplied, the default of `'utf8'` is used.
 * If `persistent` is not supplied, the default of `true` is used.
 * If `recursive` is not supplied, the default of `false` is used.
 * @param {function(string, string): void|function(string, !Buffer): void|function(string, (string|!Buffer)): void=} listener
 * @return {!fs.FSWatcher}
 */
fs.watch = function(filename, options_or_listener, listener) {};

/**
 * Asynchronously tests whether or not the given path exists by checking with the file system.
 * @deprecated
 * @param {(string|!Buffer|!url.URL)} path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {function(boolean): void} callback
 * @return {void}
 */
fs.exists = function(path, callback) {};

/**
 * @param {(string|!Buffer|!url.URL)} path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @return {!Promise<boolean>}
 */
fs.exists.__promisify__ = function(path) {};

/**
 * Synchronously tests whether or not the given path exists by checking with the file system.
 * @param {(string|!Buffer|!url.URL)} path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @return {boolean}
 */
fs.existsSync = function(path) {};
/** @const */
fs.constants = {};
/** @type {number} */
fs.constants.F_OK;
/** @type {number} */
fs.constants.R_OK;
/** @type {number} */
fs.constants.W_OK;
/** @type {number} */
fs.constants.X_OK;
/** @type {number} */
fs.constants.O_RDONLY;
/** @type {number} */
fs.constants.O_WRONLY;
/** @type {number} */
fs.constants.O_RDWR;
/** @type {number} */
fs.constants.O_CREAT;
/** @type {number} */
fs.constants.O_EXCL;
/** @type {number} */
fs.constants.O_NOCTTY;
/** @type {number} */
fs.constants.O_TRUNC;
/** @type {number} */
fs.constants.O_APPEND;
/** @type {number} */
fs.constants.O_DIRECTORY;
/** @type {number} */
fs.constants.O_NOATIME;
/** @type {number} */
fs.constants.O_NOFOLLOW;
/** @type {number} */
fs.constants.O_SYNC;
/** @type {number} */
fs.constants.O_DSYNC;
/** @type {number} */
fs.constants.O_SYMLINK;
/** @type {number} */
fs.constants.O_DIRECT;
/** @type {number} */
fs.constants.O_NONBLOCK;
/** @type {number} */
fs.constants.S_IFMT;
/** @type {number} */
fs.constants.S_IFREG;
/** @type {number} */
fs.constants.S_IFDIR;
/** @type {number} */
fs.constants.S_IFCHR;
/** @type {number} */
fs.constants.S_IFBLK;
/** @type {number} */
fs.constants.S_IFIFO;
/** @type {number} */
fs.constants.S_IFLNK;
/** @type {number} */
fs.constants.S_IFSOCK;
/** @type {number} */
fs.constants.S_IRWXU;
/** @type {number} */
fs.constants.S_IRUSR;
/** @type {number} */
fs.constants.S_IWUSR;
/** @type {number} */
fs.constants.S_IXUSR;
/** @type {number} */
fs.constants.S_IRWXG;
/** @type {number} */
fs.constants.S_IRGRP;
/** @type {number} */
fs.constants.S_IWGRP;
/** @type {number} */
fs.constants.S_IXGRP;
/** @type {number} */
fs.constants.S_IRWXO;
/** @type {number} */
fs.constants.S_IROTH;
/** @type {number} */
fs.constants.S_IWOTH;
/** @type {number} */
fs.constants.S_IXOTH;
/** @type {number} */
fs.constants.COPYFILE_EXCL;

/**
 * Asynchronously tests a user's permissions for the file specified by path.
 * @param {(string|!Buffer|!url.URL)} path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {number|function(!NodeJS.ErrnoException): void} mode_or_callback
 * @param {function(!NodeJS.ErrnoException): void=} callback
 * @return {void}
 */
fs.access = function(path, mode_or_callback, callback) {};

/**
 * Asynchronously tests a user's permissions for the file specified by path.
 * @param {(string|!Buffer|!url.URL)} path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {number=} mode
 * @return {!Promise<void>}
 */
fs.access.__promisify__ = function(path, mode) {};

/**
 * Synchronously tests a user's permissions for the file specified by path.
 * @param {(string|!Buffer|!url.URL)} path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {number=} mode
 * @return {void}
 */
fs.accessSync = function(path, mode) {};

/**
 * Returns a new `ReadStream` object.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {(string|{flags: string, encoding: string, fd: number, mode: number, autoClose: boolean, start: number, end: number, highWaterMark: number})=} options
 * @return {!fs.ReadStream}
 */
fs.createReadStream = function(path, options) {};

/**
 * Returns a new `WriteStream` object.
 * @param {(string|!Buffer|!url.URL)} path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * URL support is _experimental_.
 * @param {(string|{flags: string, encoding: string, fd: number, mode: number, autoClose: boolean, start: number})=} options
 * @return {!fs.WriteStream}
 */
fs.createWriteStream = function(path, options) {};

/**
 * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
 * @param {number} fd A file descriptor.
 * @param {function(!NodeJS.ErrnoException): void} callback
 * @return {void}
 */
fs.fdatasync = function(fd, callback) {};

/**
 * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
 * @param {number} fd A file descriptor.
 * @return {!Promise<void>}
 */
fs.fdatasync.__promisify__ = function(fd) {};

/**
 * Synchronous fdatasync(2) - synchronize a file's in-core state with storage device.
 * @param {number} fd A file descriptor.
 * @return {void}
 */
fs.fdatasyncSync = function(fd) {};

/**
 * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.
 * No arguments other than a possible exception are given to the callback function.
 * Node.js makes no guarantees about the atomicity of the copy operation.
 * If an error occurs after the destination file has been opened for writing, Node.js will attempt
 * to remove the destination.
 * @param {(string|!Buffer|!url.URL)} src A path to the source file.
 * @param {(string|!Buffer|!url.URL)} dest A path to the destination file.
 * @param {function(!NodeJS.ErrnoException): void|number} callback_or_flags An integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.
 * @param {function(!NodeJS.ErrnoException): void=} callback
 * @return {void}
 */
fs.copyFile = function(src, dest, callback_or_flags, callback) {};

/**
 * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.
 * No arguments other than a possible exception are given to the callback function.
 * Node.js makes no guarantees about the atomicity of the copy operation.
 * If an error occurs after the destination file has been opened for writing, Node.js will attempt
 * to remove the destination.
 * @param {(string|!Buffer|!url.URL)} src A path to the source file.
 * @param {(string|!Buffer|!url.URL)} dst
 * @param {number=} flags An optional integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.
 * @return {!Promise<void>}
 */
fs.copyFile.__promisify__ = function(src, dst, flags) {};

/**
 * Synchronously copies src to dest. By default, dest is overwritten if it already exists.
 * Node.js makes no guarantees about the atomicity of the copy operation.
 * If an error occurs after the destination file has been opened for writing, Node.js will attempt
 * to remove the destination.
 * @param {(string|!Buffer|!url.URL)} src A path to the source file.
 * @param {(string|!Buffer|!url.URL)} dest A path to the destination file.
 * @param {number=} flags An optional integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.
 * @return {void}
 */
fs.copyFileSync = function(src, dest, flags) {};
