/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from types-v8/tls.d.ts:
// Derived from: declare module "tls"
/** @const */
var tls = {};
/** @type {number} */
tls.CLIENT_RENEG_LIMIT;
/** @type {number} */
tls.CLIENT_RENEG_WINDOW;
/**
 * @record
 * @struct
 */
tls.Certificate = function() {};
/** @type {string} */
tls.Certificate.prototype.C;
/** @type {string} */
tls.Certificate.prototype.ST;
/** @type {string} */
tls.Certificate.prototype.L;
/** @type {string} */
tls.Certificate.prototype.O;
/** @type {string} */
tls.Certificate.prototype.OU;
/** @type {string} */
tls.Certificate.prototype.CN;
/**
 * @record
 * @struct
 */
tls.PeerCertificate = function() {};
/** @type {!tls.Certificate} */
tls.PeerCertificate.prototype.subject;
/** @type {!tls.Certificate} */
tls.PeerCertificate.prototype.issuer;
/** @type {string} */
tls.PeerCertificate.prototype.subjectaltname;
/** @type {!Object<string,!Array<string>>} */
tls.PeerCertificate.prototype.infoAccess;
/** @type {string} */
tls.PeerCertificate.prototype.modulus;
/** @type {string} */
tls.PeerCertificate.prototype.exponent;
/** @type {string} */
tls.PeerCertificate.prototype.valid_from;
/** @type {string} */
tls.PeerCertificate.prototype.valid_to;
/** @type {string} */
tls.PeerCertificate.prototype.fingerprint;
/** @type {!Array<string>} */
tls.PeerCertificate.prototype.ext_key_usage;
/** @type {string} */
tls.PeerCertificate.prototype.serialNumber;
/** @type {!Buffer} */
tls.PeerCertificate.prototype.raw;
/**
 * @extends {tls.PeerCertificate}
 * @record
 * @struct
 */
tls.DetailedPeerCertificate = function() {};
/** @type {!tls.DetailedPeerCertificate} */
tls.DetailedPeerCertificate.prototype.issuerCertificate;
/**
 * @record
 * @struct
 */
tls.CipherNameAndProtocol = function() {};
/** @type {string} */
tls.CipherNameAndProtocol.prototype.name;
/** @type {string} */
tls.CipherNameAndProtocol.prototype.version;

/**
 * @extends {net.Socket}
 * @constructor
 * @struct
 * Construct a new tls.TLSSocket object from an existing TCP socket.
 * @param {!net.Socket} socket
 * @param {{secureContext: !tls.SecureContext, isServer: boolean, server: !net.Server, requestCert: boolean, rejectUnauthorized: boolean, NPNProtocols: (!Array<string>|!Buffer|!Array<!Buffer>|!Uint8Array|!Array<!Uint8Array>), ALPNProtocols: (!Array<string>|!Buffer|!Array<!Buffer>|!Uint8Array|!Array<!Uint8Array>), SNICallback: function(string, function(!Error, !tls.SecureContext): void): void, session: !Buffer, requestOCSP: boolean}=} options
 */
tls.TLSSocket = function(socket, options) {};
/** @type {boolean} */
tls.TLSSocket.prototype.authorized;
/** @type {!Error} */
tls.TLSSocket.prototype.authorizationError;
/** @type {boolean} */
tls.TLSSocket.prototype.encrypted;

/**
 * Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection.
 * @return {!tls.CipherNameAndProtocol} Returns an object representing the cipher name
 * and the SSL/TLS protocol version of the current connection.
 */
tls.TLSSocket.prototype.getCipher = function() {};

/**
 * Returns an object representing the peer's certificate.
 * The returned object has some properties corresponding to the field of the certificate.
 * If detailed argument is true the full chain with issuer property will be returned,
 * if false only the top certificate without issuer property.
 * If the peer does not provide a certificate, it returns null or an empty object.
 * @param {boolean=} detailed - If true; the full chain with issuer property will be returned.
 * @return {!tls.DetailedPeerCertificate|!tls.PeerCertificate|(!tls.DetailedPeerCertificate|!tls.PeerCertificate)} An object representing the peer's certificate.
 */
tls.TLSSocket.prototype.getPeerCertificate = function(detailed) {};

/**
 * Returns a string containing the negotiated SSL/TLS protocol version of the current connection.
 * The value `'unknown'` will be returned for connected sockets that have not completed the handshaking process.
 * The value `null` will be returned for server sockets or disconnected client sockets.
 * See https://www.openssl.org/docs/man1.0.2/ssl/SSL_get_version.html for more information.
 * @return {string} negotiated SSL/TLS protocol version of the current connection
 */
tls.TLSSocket.prototype.getProtocol = function() {};

/**
 * Could be used to speed up handshake establishment when reconnecting to the server.
 * @return {?} ASN.1 encoded TLS session or undefined if none was negotiated.
 */
tls.TLSSocket.prototype.getSession = function() {};

/**
 * NOTE: Works only with client TLS sockets.
 * Useful only for debugging, for session reuse provide session option to tls.connect().
 * @return {?} TLS session ticket or undefined if none was negotiated.
 */
tls.TLSSocket.prototype.getTLSTicket = function() {};

/**
 * Initiate TLS renegotiation process.
 *
 * NOTE: Can be used to request peer's certificate after the secure connection has been established.
 * ANOTHER NOTE: When running as the server, socket will be destroyed with an error after handshakeTimeout timeout.
 * @param {{rejectUnauthorized: boolean, requestCert: boolean}} options - The options may contain the following fields: rejectUnauthorized,
 * requestCert (See tls.createServer() for details).
 * @param {function(!Error): void} callback - callback(err) will be executed with null as err, once the renegotiation
 * is successfully completed.
 * @return {?}
 */
tls.TLSSocket.prototype.renegotiate = function(options, callback) {};

/**
 * Set maximum TLS fragment size (default and maximum value is: 16384, minimum is: 512).
 * Smaller fragment size decreases buffering latency on the client: large fragments are buffered by
 * the TLS layer until the entire fragment is received and its integrity is verified;
 * large fragments can span multiple roundtrips, and their processing can be delayed due to packet
 * loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead,
 * which may decrease overall server throughput.
 * @param {number} size - TLS fragment size (default and maximum value is: 16384, minimum is: 512).
 * @return {boolean} Returns true on success, false otherwise.
 */
tls.TLSSocket.prototype.setMaxSendFragment = function(size) {};

/**
 * events.EventEmitter
 * 1. OCSPResponse
 * 2. secureConnect
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(!Buffer): void|function(): void} listener
 * @return {THIS}
 */
tls.TLSSocket.prototype.addListener = function(event, listener) {};

/**
 * @param {(string|symbol)|string} event
 * @param {...?|!Buffer} args_or_response
 * @return {boolean}
 */
tls.TLSSocket.prototype.emit = function(event, args_or_response) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(!Buffer): void|function(): void} listener
 * @return {THIS}
 */
tls.TLSSocket.prototype.on = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(!Buffer): void|function(): void} listener
 * @return {THIS}
 */
tls.TLSSocket.prototype.once = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(!Buffer): void|function(): void} listener
 * @return {THIS}
 */
tls.TLSSocket.prototype.prependListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(!Buffer): void|function(): void} listener
 * @return {THIS}
 */
tls.TLSSocket.prototype.prependOnceListener = function(event, listener) {};
/**
 * @extends {tls.SecureContextOptions}
 * @record
 * @struct
 */
tls.TlsOptions = function() {};
/** @type {number} */
tls.TlsOptions.prototype.handshakeTimeout;
/** @type {boolean} */
tls.TlsOptions.prototype.requestCert;
/** @type {boolean} */
tls.TlsOptions.prototype.rejectUnauthorized;
/** @type {(!Array<string>|!Buffer|!Array<!Buffer>|!Uint8Array|!Array<!Uint8Array>)} */
tls.TlsOptions.prototype.NPNProtocols;
/** @type {(!Array<string>|!Buffer|!Array<!Buffer>|!Uint8Array|!Array<!Uint8Array>)} */
tls.TlsOptions.prototype.ALPNProtocols;
/** @type {function(string, function(!Error, !tls.SecureContext): void): void} */
tls.TlsOptions.prototype.SNICallback;
/** @type {number} */
tls.TlsOptions.prototype.sessionTimeout;
/** @type {!Buffer} */
tls.TlsOptions.prototype.ticketKeys;
/**
 * @extends {tls.SecureContextOptions}
 * @record
 * @struct
 */
tls.ConnectionOptions = function() {};
/** @type {string} */
tls.ConnectionOptions.prototype.host;
/** @type {number} */
tls.ConnectionOptions.prototype.port;
/** @type {string} */
tls.ConnectionOptions.prototype.path;
/** @type {!net.Socket} */
tls.ConnectionOptions.prototype.socket;
/** @type {boolean} */
tls.ConnectionOptions.prototype.rejectUnauthorized;
/** @type {(!Array<string>|!Buffer|!Array<!Buffer>|!Uint8Array|!Array<!Uint8Array>)} */
tls.ConnectionOptions.prototype.NPNProtocols;
/** @type {(!Array<string>|!Buffer|!Array<!Buffer>|!Uint8Array|!Array<!Uint8Array>)} */
tls.ConnectionOptions.prototype.ALPNProtocols;
/** @type {function(string, !tls.PeerCertificate): !Error} */
tls.ConnectionOptions.prototype.checkServerIdentity;
/** @type {string} */
tls.ConnectionOptions.prototype.servername;
/** @type {!Buffer} */
tls.ConnectionOptions.prototype.session;
/** @type {number} */
tls.ConnectionOptions.prototype.minDHSize;
/** @type {!tls.SecureContext} */
tls.ConnectionOptions.prototype.secureContext;
/** @type {function(string, !dns.LookupOneOptions, function(!NodeJS.ErrnoException, string, number): void): void} */
tls.ConnectionOptions.prototype.lookup;
/**
 * @extends {net.Server}
 * @constructor
 * @struct
 */
tls.Server = function() {};

/**
 * @param {string} hostName
 * @param {{key: string, cert: string, ca: string}} credentials
 * @return {void}
 */
tls.Server.prototype.addContext = function(hostName, credentials) {};

/**
 * events.EventEmitter
 * 1. tlsClientError
 * 2. newSession
 * 3. OCSPRequest
 * 4. resumeSession
 * 5. secureConnection
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(!Error, !tls.TLSSocket): void|function(?, ?, function(!Error, !Buffer): void): void|function(!Buffer, !Buffer, !Function): void|function(?, function(!Error, ?): void): void|function(!tls.TLSSocket): void} listener
 * @return {THIS}
 */
tls.Server.prototype.addListener = function(event, listener) {};

/**
 * @param {(string|symbol)|string} event
 * @param {...?|!Error|!Buffer|!tls.TLSSocket} args_or_err_or_sessionId_or_certificate_or_tlsSocket
 * @return {boolean}
 */
tls.Server.prototype.emit = function(event, args_or_err_or_sessionId_or_certificate_or_tlsSocket) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(!Error, !tls.TLSSocket): void|function(?, ?, function(!Error, !Buffer): void): void|function(!Buffer, !Buffer, !Function): void|function(?, function(!Error, ?): void): void|function(!tls.TLSSocket): void} listener
 * @return {THIS}
 */
tls.Server.prototype.on = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(!Error, !tls.TLSSocket): void|function(?, ?, function(!Error, !Buffer): void): void|function(!Buffer, !Buffer, !Function): void|function(?, function(!Error, ?): void): void|function(!tls.TLSSocket): void} listener
 * @return {THIS}
 */
tls.Server.prototype.once = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(!Error, !tls.TLSSocket): void|function(?, ?, function(!Error, !Buffer): void): void|function(!Buffer, !Buffer, !Function): void|function(?, function(!Error, ?): void): void|function(!tls.TLSSocket): void} listener
 * @return {THIS}
 */
tls.Server.prototype.prependListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(!Error, !tls.TLSSocket): void|function(?, ?, function(!Error, !Buffer): void): void|function(!Buffer, !Buffer, !Function): void|function(?, function(!Error, ?): void): void|function(!tls.TLSSocket): void} listener
 * @return {THIS}
 */
tls.Server.prototype.prependOnceListener = function(event, listener) {};
/**
 * @extends {stream.Duplex}
 * @record
 * @struct
 */
tls.ClearTextStream = function() {};
/** @type {boolean} */
tls.ClearTextStream.prototype.authorized;
/** @type {!Error} */
tls.ClearTextStream.prototype.authorizationError;
/** @type {{name: string, version: string}} */
tls.ClearTextStream.prototype.getCipher;
/** @type {{port: number, family: string, address: string}} */
tls.ClearTextStream.prototype.address;
/** @type {string} */
tls.ClearTextStream.prototype.remoteAddress;
/** @type {number} */
tls.ClearTextStream.prototype.remotePort;

/**
 * @return {?}
 */
tls.ClearTextStream.prototype.getPeerCertificate = function() {};
/**
 * @record
 * @struct
 */
tls.SecurePair = function() {};
/** @type {?} */
tls.SecurePair.prototype.encrypted;
/** @type {?} */
tls.SecurePair.prototype.cleartext;
/**
 * @record
 * @struct
 */
tls.SecureContextOptions = function() {};
/** @type {(string|!Buffer|!Array<(string|!Object|!Buffer)>)} */
tls.SecureContextOptions.prototype.pfx;
/** @type {(string|!Buffer|!Array<(!Object|!Buffer)>)} */
tls.SecureContextOptions.prototype.key;
/** @type {string} */
tls.SecureContextOptions.prototype.passphrase;
/** @type {(string|!Buffer|!Array<(string|!Buffer)>)} */
tls.SecureContextOptions.prototype.cert;
/** @type {(string|!Buffer|!Array<(string|!Buffer)>)} */
tls.SecureContextOptions.prototype.ca;
/** @type {string} */
tls.SecureContextOptions.prototype.ciphers;
/** @type {boolean} */
tls.SecureContextOptions.prototype.honorCipherOrder;
/** @type {string} */
tls.SecureContextOptions.prototype.ecdhCurve;
/** @type {(string|!Buffer|!Array<(string|!Buffer)>)} */
tls.SecureContextOptions.prototype.crl;
/** @type {(string|!Buffer)} */
tls.SecureContextOptions.prototype.dhparam;
/** @type {number} */
tls.SecureContextOptions.prototype.secureOptions;
/** @type {string} */
tls.SecureContextOptions.prototype.secureProtocol;
/** @type {string} */
tls.SecureContextOptions.prototype.sessionIdContext;
/**
 * @record
 * @struct
 */
tls.SecureContext = function() {};
/** @type {?} */
tls.SecureContext.prototype.context;

/**
 * @param {string} host
 * @param {!tls.PeerCertificate} cert
 * @return {!Error}
 */
tls.checkServerIdentity = function(host, cert) {};

/**
 * @param {!tls.TlsOptions} options
 * @param {function(!tls.TLSSocket): void=} secureConnectionListener
 * @return {!tls.Server}
 */
tls.createServer = function(options, secureConnectionListener) {};

/**
 * @param {!tls.ConnectionOptions|number} options_or_port
 * @param {function(): void|string|!tls.ConnectionOptions=} secureConnectionListener_or_host_or_options
 * @param {!tls.ConnectionOptions|function(): void=} options_or_secureConnectListener
 * @param {function(): void=} secureConnectListener
 * @return {!tls.TLSSocket}
 */
tls.connect = function(options_or_port, secureConnectionListener_or_host_or_options, options_or_secureConnectListener, secureConnectListener) {};

/**
 * @param {!crypto.Credentials=} credentials
 * @param {boolean=} isServer
 * @param {boolean=} requestCert
 * @param {boolean=} rejectUnauthorized
 * @return {!tls.SecurePair}
 */
tls.createSecurePair = function(credentials, isServer, requestCert, rejectUnauthorized) {};

/**
 * @param {!tls.SecureContextOptions} details
 * @return {!tls.SecureContext}
 */
tls.createSecureContext = function(details) {};

/**
 * @return {!Array<string>}
 */
tls.getCiphers = function() {};
/** @type {string} */
tls.DEFAULT_ECDH_CURVE;
