/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from types-v8/readline.d.ts:
// Derived from: declare module "readline"
/** @const */
var readline = {};
/**
 * @record
 * @struct
 */
readline.Key = function() {};
/** @type {string} */
readline.Key.prototype.sequence;
/** @type {string} */
readline.Key.prototype.name;
/** @type {boolean} */
readline.Key.prototype.ctrl;
/** @type {boolean} */
readline.Key.prototype.meta;
/** @type {boolean} */
readline.Key.prototype.shift;
/**
 * @extends {events.EventEmitter}
 * @record
 * @struct
 */
readline.ReadLine = function() {};

/**
 * @param {string} prompt
 * @return {void}
 */
readline.ReadLine.prototype.setPrompt = function(prompt) {};

/**
 * @param {boolean=} preserveCursor
 * @return {void}
 */
readline.ReadLine.prototype.prompt = function(preserveCursor) {};

/**
 * @param {string} query
 * @param {function(string): void} callback
 * @return {void}
 */
readline.ReadLine.prototype.question = function(query, callback) {};

/**
 * @return {!readline.ReadLine}
 */
readline.ReadLine.prototype.pause = function() {};

/**
 * @return {!readline.ReadLine}
 */
readline.ReadLine.prototype.resume = function() {};

/**
 * @return {void}
 */
readline.ReadLine.prototype.close = function() {};

/**
 * @param {(string|!Buffer)} data
 * @param {!readline.Key=} key
 * @return {void}
 */
readline.ReadLine.prototype.write = function(data, key) {};

/**
 * events.EventEmitter
 * 1. close
 * 2. line
 * 3. pause
 * 4. resume
 * 5. SIGCONT
 * 6. SIGINT
 * 7. SIGTSTP
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(?): void} listener
 * @return {THIS}
 */
readline.ReadLine.prototype.addListener = function(event, listener) {};

/**
 * @param {(string|symbol)|string} event
 * @param {...?} args_or_input
 * @return {boolean}
 */
readline.ReadLine.prototype.emit = function(event, args_or_input) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(?): void} listener
 * @return {THIS}
 */
readline.ReadLine.prototype.on = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(?): void} listener
 * @return {THIS}
 */
readline.ReadLine.prototype.once = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(?): void} listener
 * @return {THIS}
 */
readline.ReadLine.prototype.prependListener = function(event, listener) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {string} event
 * @param {function(...?): void|function(): void|function(?): void} listener
 * @return {THIS}
 */
readline.ReadLine.prototype.prependOnceListener = function(event, listener) {};

/** @typedef {function(string): !Array<?>} */
readline.Completer;

/** @typedef {function(string, function(?, !Array<?>): void): ?} */
readline.AsyncCompleter;

/** @typedef {!Array<?>} */
readline.CompleterResult;
/**
 * @record
 * @struct
 */
readline.ReadLineOptions = function() {};
/** @type {!NodeJS.ReadableStream} */
readline.ReadLineOptions.prototype.input;
/** @type {!NodeJS.WritableStream} */
readline.ReadLineOptions.prototype.output;
/** @type {(function(string): !Array<?>|function(string, function(?, !Array<?>): void): ?)} */
readline.ReadLineOptions.prototype.completer;
/** @type {boolean} */
readline.ReadLineOptions.prototype.terminal;
/** @type {number} */
readline.ReadLineOptions.prototype.historySize;
/** @type {string} */
readline.ReadLineOptions.prototype.prompt;
/** @type {number} */
readline.ReadLineOptions.prototype.crlfDelay;
/** @type {boolean} */
readline.ReadLineOptions.prototype.removeHistoryDuplicates;

/**
 * @param {!NodeJS.ReadableStream|!readline.ReadLineOptions} input_or_options
 * @param {!NodeJS.WritableStream=} output
 * @param {(function(string): !Array<?>|function(string, function(?, !Array<?>): void): ?)=} completer
 * @param {boolean=} terminal
 * @return {!readline.ReadLine}
 */
readline.createInterface = function(input_or_options, output, completer, terminal) {};

/**
 * @param {!NodeJS.WritableStream} stream
 * @param {number} x
 * @param {number=} y
 * @return {void}
 */
readline.cursorTo = function(stream, x, y) {};

/**
 * @param {!NodeJS.ReadableStream} stream
 * @param {!readline.ReadLine=} interface
 * @return {void}
 */
readline.emitKeypressEvents = function(stream, interface) {};

/**
 * @param {!NodeJS.WritableStream} stream
 * @param {(string|number)} dx
 * @param {(string|number)} dy
 * @return {void}
 */
readline.moveCursor = function(stream, dx, dy) {};

/**
 * @param {!NodeJS.WritableStream} stream
 * @param {number} dir
 * @return {void}
 */
readline.clearLine = function(stream, dir) {};

/**
 * @param {!NodeJS.WritableStream} stream
 * @return {void}
 */
readline.clearScreenDown = function(stream) {};
