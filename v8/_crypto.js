/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from types-v8/crypto.d.ts:
// Derived from: declare module "crypto"
/** @const */
var _crypto = {};
/**
 * @record
 * @struct
 */
_crypto.Certificate = function() {};

/**
 * @param {(string|!Buffer)} spkac
 * @return {!Buffer}
 */
_crypto.Certificate.prototype.exportChallenge = function(spkac) {};

/**
 * @param {(string|!Buffer)} spkac
 * @return {!Buffer}
 */
_crypto.Certificate.prototype.exportPublicKey = function(spkac) {};

/**
 * @param {!Buffer} spkac
 * @return {boolean}
 */
_crypto.Certificate.prototype.verifySpkac = function(spkac) {};
/** @type {function(new: (?)): ?} */
_crypto.Certificate;
/** @type {boolean} */
_crypto.fips;
/**
 * @record
 * @struct
 */
_crypto.CredentialDetails = function() {};
/** @type {string} */
_crypto.CredentialDetails.prototype.pfx;
/** @type {string} */
_crypto.CredentialDetails.prototype.key;
/** @type {string} */
_crypto.CredentialDetails.prototype.passphrase;
/** @type {string} */
_crypto.CredentialDetails.prototype.cert;
/** @type {(string|!Array<string>)} */
_crypto.CredentialDetails.prototype.ca;
/** @type {(string|!Array<string>)} */
_crypto.CredentialDetails.prototype.crl;
/** @type {string} */
_crypto.CredentialDetails.prototype.ciphers;
/**
 * @record
 * @struct
 */
_crypto.Credentials = function() {};
/** @type {?|undefined} */
_crypto.Credentials.prototype.context;

/**
 * @param {!_crypto.CredentialDetails} details
 * @return {!_crypto.Credentials}
 */
_crypto.createCredentials = function(details) {};

/**
 * @param {string} algorithm
 * @return {!_crypto.Hash}
 */
_crypto.createHash = function(algorithm) {};

/**
 * @param {string} algorithm
 * @param {(string|!Buffer)} key
 * @return {!_crypto.Hmac}
 */
_crypto.createHmac = function(algorithm, key) {};

/** @typedef {string} */
_crypto.Utf8AsciiLatin1Encoding;

/** @typedef {string} */
_crypto.HexBase64Latin1Encoding;

/** @typedef {string} */
_crypto.Utf8AsciiBinaryEncoding;

/** @typedef {string} */
_crypto.HexBase64BinaryEncoding;

/** @typedef {string} */
_crypto.ECDHKeyFormat;
/**
 * @extends {NodeJS.ReadWriteStream}
 * @record
 * @struct
 */
_crypto.Hash = function() {};

/**
 * @param {(string|!Buffer|!DataView)} data
 * @param {string=} input_encoding
 * @return {!_crypto.Hash}
 */
_crypto.Hash.prototype.update = function(data, input_encoding) {};

/**
 * @param {string=} encoding
 * @return {!Buffer|string}
 */
_crypto.Hash.prototype.digest = function(encoding) {};
/**
 * @extends {NodeJS.ReadWriteStream}
 * @record
 * @struct
 */
_crypto.Hmac = function() {};

/**
 * @param {(string|!Buffer|!DataView)} data
 * @param {string=} input_encoding
 * @return {!_crypto.Hmac}
 */
_crypto.Hmac.prototype.update = function(data, input_encoding) {};

/**
 * @param {string=} encoding
 * @return {!Buffer|string}
 */
_crypto.Hmac.prototype.digest = function(encoding) {};

/**
 * @param {string} algorithm
 * @param {?} password
 * @return {!_crypto.Cipher}
 */
_crypto.createCipher = function(algorithm, password) {};

/**
 * @param {string} algorithm
 * @param {?} key
 * @param {?} iv
 * @return {!_crypto.Cipher}
 */
_crypto.createCipheriv = function(algorithm, key, iv) {};
/**
 * @extends {NodeJS.ReadWriteStream}
 * @record
 * @struct
 */
_crypto.Cipher = function() {};

/**
 * @param {(!Buffer|!DataView)|string} data
 * @param {string|?=} input_encoding
 * @param {string=} output_encoding
 * @return {!Buffer|string}
 */
_crypto.Cipher.prototype.update = function(data, input_encoding, output_encoding) {};

/**
 * @param {string=} output_encoding
 * @return {!Buffer|string}
 */
_crypto.Cipher.prototype.final = function(output_encoding) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {boolean=} auto_padding
 * @return {THIS}
 */
_crypto.Cipher.prototype.setAutoPadding = function(auto_padding) {};

/**
 * @return {!Buffer}
 */
_crypto.Cipher.prototype.getAuthTag = function() {};

/**
 * @template THIS
 * @this {THIS}
 * @param {!Buffer} buffer
 * @return {THIS}
 */
_crypto.Cipher.prototype.setAAD = function(buffer) {};

/**
 * @param {string} algorithm
 * @param {?} password
 * @return {!_crypto.Decipher}
 */
_crypto.createDecipher = function(algorithm, password) {};

/**
 * @param {string} algorithm
 * @param {?} key
 * @param {?} iv
 * @return {!_crypto.Decipher}
 */
_crypto.createDecipheriv = function(algorithm, key, iv) {};
/**
 * @extends {NodeJS.ReadWriteStream}
 * @record
 * @struct
 */
_crypto.Decipher = function() {};

/**
 * @param {(!Buffer|!DataView)|string} data
 * @param {string|?=} input_encoding
 * @param {string=} output_encoding
 * @return {!Buffer|string}
 */
_crypto.Decipher.prototype.update = function(data, input_encoding, output_encoding) {};

/**
 * @param {string=} output_encoding
 * @return {!Buffer|string}
 */
_crypto.Decipher.prototype.final = function(output_encoding) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {boolean=} auto_padding
 * @return {THIS}
 */
_crypto.Decipher.prototype.setAutoPadding = function(auto_padding) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {!Buffer} tag
 * @return {THIS}
 */
_crypto.Decipher.prototype.setAuthTag = function(tag) {};

/**
 * @template THIS
 * @this {THIS}
 * @param {!Buffer} buffer
 * @return {THIS}
 */
_crypto.Decipher.prototype.setAAD = function(buffer) {};

/**
 * @param {string} algorithm
 * @return {!_crypto.Signer}
 */
_crypto.createSign = function(algorithm) {};
/**
 * @extends {NodeJS.WritableStream}
 * @record
 * @struct
 */
_crypto.Signer = function() {};

/**
 * @param {(string|!Buffer|!DataView)} data
 * @param {string=} input_encoding
 * @return {!_crypto.Signer}
 */
_crypto.Signer.prototype.update = function(data, input_encoding) {};

/**
 * @param {(string|{key: string, passphrase: string})} private_key
 * @param {string=} output_format
 * @return {!Buffer|string}
 */
_crypto.Signer.prototype.sign = function(private_key, output_format) {};

/**
 * @param {string} algorith
 * @return {!_crypto.Verify}
 */
_crypto.createVerify = function(algorith) {};
/**
 * @extends {NodeJS.WritableStream}
 * @record
 * @struct
 */
_crypto.Verify = function() {};

/**
 * @param {(string|!Buffer|!DataView)} data
 * @param {string=} input_encoding
 * @return {!_crypto.Verify}
 */
_crypto.Verify.prototype.update = function(data, input_encoding) {};

/**
 * @param {(string|!Object)} object
 * @param {(!Buffer|!DataView)|string} signature
 * @param {string=} signature_format
 * @return {boolean}
 */
_crypto.Verify.prototype.verify = function(object, signature, signature_format) {};

/**
 * @param {number|!Buffer|string} prime_length_or_prime
 * @param {number|string=} generator_or_prime_encoding
 * @param {(number|!Buffer)|string=} generator
 * @param {string=} generator_encoding
 * @return {!_crypto.DiffieHellman}
 */
_crypto.createDiffieHellman = function(prime_length_or_prime, generator_or_prime_encoding, generator, generator_encoding) {};
/**
 * @record
 * @struct
 */
_crypto.DiffieHellman = function() {};
/** @type {number} */
_crypto.DiffieHellman.prototype.verifyError;

/**
 * @param {string=} encoding
 * @return {!Buffer|string}
 */
_crypto.DiffieHellman.prototype.generateKeys = function(encoding) {};

/**
 * @param {!Buffer|string} other_public_key
 * @param {string=} input_encoding
 * @param {string=} output_encoding
 * @return {!Buffer|string}
 */
_crypto.DiffieHellman.prototype.computeSecret = function(other_public_key, input_encoding, output_encoding) {};

/**
 * @param {string=} encoding
 * @return {!Buffer|string}
 */
_crypto.DiffieHellman.prototype.getPrime = function(encoding) {};

/**
 * @param {string=} encoding
 * @return {!Buffer|string}
 */
_crypto.DiffieHellman.prototype.getGenerator = function(encoding) {};

/**
 * @param {string=} encoding
 * @return {!Buffer|string}
 */
_crypto.DiffieHellman.prototype.getPublicKey = function(encoding) {};

/**
 * @param {string=} encoding
 * @return {!Buffer|string}
 */
_crypto.DiffieHellman.prototype.getPrivateKey = function(encoding) {};

/**
 * @param {!Buffer|string} public_key
 * @param {string=} encoding
 * @return {void}
 */
_crypto.DiffieHellman.prototype.setPublicKey = function(public_key, encoding) {};

/**
 * @param {!Buffer|string} private_key
 * @param {string=} encoding
 * @return {void}
 */
_crypto.DiffieHellman.prototype.setPrivateKey = function(private_key, encoding) {};

/**
 * @param {string} group_name
 * @return {!_crypto.DiffieHellman}
 */
_crypto.getDiffieHellman = function(group_name) {};

/**
 * @param {(string|!Buffer)} password
 * @param {(string|!Buffer)} salt
 * @param {number} iterations
 * @param {number} keylen
 * @param {string} digest
 * @param {function(!Error, !Buffer): ?} callback
 * @return {void}
 */
_crypto.pbkdf2 = function(password, salt, iterations, keylen, digest, callback) {};

/**
 * @param {(string|!Buffer)} password
 * @param {(string|!Buffer)} salt
 * @param {number} iterations
 * @param {number} keylen
 * @param {string} digest
 * @return {!Buffer}
 */
_crypto.pbkdf2Sync = function(password, salt, iterations, keylen, digest) {};

/**
 * @param {number} size
 * @param {function(!Error, !Buffer): void=} callback
 * @return {!Buffer|void}
 */
_crypto.randomBytes = function(size, callback) {};

/**
 * @param {number} size
 * @param {function(!Error, !Buffer): void=} callback
 * @return {!Buffer|void}
 */
_crypto.pseudoRandomBytes = function(size, callback) {};

/**
 * @param {(!Buffer|!Uint8Array)} buffer
 * @param {number=} offset
 * @param {number=} size
 * @return {!Buffer}
 */
_crypto.randomFillSync = function(buffer, offset, size) {};

/**
 * @param {!Buffer|!Uint8Array} buffer
 * @param {function(!Error, !Buffer): void|function(!Error, !Uint8Array): void|number} callback_or_offset
 * @param {function(!Error, !Buffer): void|function(!Error, !Uint8Array): void|number=} callback_or_size
 * @param {function(!Error, !Buffer): void|function(!Error, !Uint8Array): void=} callback
 * @return {void}
 */
_crypto.randomFill = function(buffer, callback_or_offset, callback_or_size, callback) {};
/**
 * @record
 * @struct
 */
_crypto.RsaPublicKey = function() {};
/** @type {string} */
_crypto.RsaPublicKey.prototype.key;
/** @type {number} */
_crypto.RsaPublicKey.prototype.padding;
/**
 * @record
 * @struct
 */
_crypto.RsaPrivateKey = function() {};
/** @type {string} */
_crypto.RsaPrivateKey.prototype.key;
/** @type {string} */
_crypto.RsaPrivateKey.prototype.passphrase;
/** @type {number} */
_crypto.RsaPrivateKey.prototype.padding;

/**
 * @param {(string|!_crypto.RsaPublicKey)} public_key
 * @param {!Buffer} buffer
 * @return {!Buffer}
 */
_crypto.publicEncrypt = function(public_key, buffer) {};

/**
 * @param {(string|!_crypto.RsaPrivateKey)} private_key
 * @param {!Buffer} buffer
 * @return {!Buffer}
 */
_crypto.privateDecrypt = function(private_key, buffer) {};

/**
 * @param {(string|!_crypto.RsaPrivateKey)} private_key
 * @param {!Buffer} buffer
 * @return {!Buffer}
 */
_crypto.privateEncrypt = function(private_key, buffer) {};

/**
 * @param {(string|!_crypto.RsaPublicKey)} public_key
 * @param {!Buffer} buffer
 * @return {!Buffer}
 */
_crypto.publicDecrypt = function(public_key, buffer) {};

/**
 * @return {!Array<string>}
 */
_crypto.getCiphers = function() {};

/**
 * @return {!Array<string>}
 */
_crypto.getCurves = function() {};

/**
 * @return {!Array<string>}
 */
_crypto.getHashes = function() {};
/**
 * @record
 * @struct
 */
_crypto.ECDH = function() {};

/**
 * @param {string=} encoding
 * @param {string=} format
 * @return {!Buffer|string}
 */
_crypto.ECDH.prototype.generateKeys = function(encoding, format) {};

/**
 * @param {!Buffer|string} other_public_key
 * @param {string=} input_encoding
 * @param {string=} output_encoding
 * @return {!Buffer|string}
 */
_crypto.ECDH.prototype.computeSecret = function(other_public_key, input_encoding, output_encoding) {};

/**
 * @param {string=} encoding
 * @return {!Buffer|string}
 */
_crypto.ECDH.prototype.getPrivateKey = function(encoding) {};

/**
 * @param {string=} encoding
 * @param {string=} format
 * @return {!Buffer|string}
 */
_crypto.ECDH.prototype.getPublicKey = function(encoding, format) {};

/**
 * @param {!Buffer|string} private_key
 * @param {string=} encoding
 * @return {void}
 */
_crypto.ECDH.prototype.setPrivateKey = function(private_key, encoding) {};

/**
 * @param {string} curve_name
 * @return {!_crypto.ECDH}
 */
_crypto.createECDH = function(curve_name) {};

/**
 * @param {!Buffer} a
 * @param {!Buffer} b
 * @return {boolean}
 */
_crypto.timingSafeEqual = function(a, b) {};
/** @type {string} */
_crypto.DEFAULT_ENCODING;
